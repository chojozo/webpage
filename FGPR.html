<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ë¯¸ë˜ì„±ì¥í™œë™ ì°¸ì—¬ í˜„í™© ë³´ê³ ì„œ</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'Segoe UI','Malgun Gothic',sans-serif;background:#fff;color:#2C3E50}
    .container{max-width:1400px;margin:0 auto;padding:26px 18px}
    header{border-bottom:2px solid #4A90E2;padding-bottom:16px;margin-bottom:18px}
    h1{font-size:1.5em;font-weight:800;margin-bottom:14px;color:#1a1a1a}
    .meta-row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .meta-item{display:flex;align-items:center;gap:8px;background:linear-gradient(135deg,#e0f2fe 0%,#dbeafe 100%);
      border:1px solid #93c5fd;border-radius:8px;padding:8px 16px;font-size:.88em;
      box-shadow:0 1px 3px rgba(59,130,246,0.1)}
    .meta-label{font-weight:700;color:#1e40af;font-size:.9em}
    .meta-value{font-weight:700;color:#1e3a8a}
    .meta-item.period{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
      border:none;color:#fff;box-shadow:0 2px 8px rgba(102,126,234,0.25)}
    .meta-item.period .meta-label{color:rgba(255,255,255,0.9)}
    .meta-item.period .meta-value{color:#fff;font-weight:700}

    /* One-page feel */
    .grid{display:grid;gap:10px}
    .top-grid{grid-template-columns:1.25fr 1fr 1fr 1fr;margin-bottom:8px}
    @media (max-width:1100px){.top-grid{grid-template-columns:1fr 1fr}}
    @media (max-width:720px){.top-grid{grid-template-columns:1fr}}

    .card{background:#fff;border:1px solid #EAEAEA;border-radius:14px;padding:12px 14px;
      box-shadow:0 3px 14px rgba(0,0,0,.06);display:flex;flex-direction:column;gap:10px}
    .card.total{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;border:none}
    .card-title{font-weight:900;font-size:.95em;text-align:center;padding-bottom:10px;
      border-bottom:2px solid rgba(0,0,0,.08)}
    .card.total .card-title{border-bottom-color:rgba(255,255,255,.25)}

    .mini-row{display:flex;align-items:center;justify-content:center;gap:12px;padding:4px 0}
    .donutWrap{width:70px;height:70px;position:relative;flex:0 0 auto}
    .donutWrap.big{width:70px;height:70px}
    canvas{max-width:100%}
    .centerTxt{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
      flex-direction:column;pointer-events:none;text-align:center}
    .centerTxt .pct{font-weight:900;line-height:1;font-size:17px}
    .centerTxt .sub{font-size:11px;color:#5D6D7E;margin-top:3px}
    .card.total .centerTxt .sub{color:rgba(255,255,255,.85)}
    .metric{display:flex;flex-direction:column;gap:5px;min-width:0;flex:1}
    .metric .main{font-size:.88em;font-weight:900;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
      padding:5px 8px;background:rgba(0,0,0,.03);border-radius:6px;text-align:center}
    .metric .hint{font-size:.84em;color:#5D6D7E;padding:4px 8px;text-align:center;
      background:rgba(0,0,0,.02);border-radius:6px}
    .card.total .metric .main{color:#fff;background:rgba(255,255,255,.15);font-weight:900}
    .card.total .metric .hint{color:rgba(255,255,255,.9);background:rgba(255,255,255,.1)}

    .section{background:#F8F9FA;border-radius:16px;padding:10px 16px 12px;box-shadow:0 4px 18px rgba(0,0,0,.05);margin-top:4px}
    .section-title{display:flex;align-items:center;gap:10px;font-size:1.1em;font-weight:900;margin-bottom:6px}
    .bar{width:4px;height:18px;background:#4A90E2;border-radius:2px}

    .tabs{display:flex;gap:10px;border-bottom:2px solid #EAEAEA;margin-bottom:6px}
    .tab{border:none;background:#fff;padding:10px 16px;font-weight:700;color:#7D7D7D;cursor:pointer;
      border-bottom:3px solid transparent;position:relative;bottom:-2px;transition:all .2s ease;
      border-radius:10px 10px 0 0}
    .tab:hover{color:#2C3E50;background:#F1F3F6}

    /* Active states with stronger colors */
    .tab.active{color:#fff;font-weight:900;transform:translateY(-2px);
      box-shadow:0 4px 12px rgba(0,0,0,0.15)}
    .tab.active.total{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
      border-bottom-color:#667eea}
    .tab.active.b{background:linear-gradient(135deg,#4A5FD9 0%,#667eea 100%);
      border-bottom-color:#4A5FD9}
    .tab.active.a{background:linear-gradient(135deg,#11998e 0%,#38ef7d 100%);
      border-bottom-color:#11998e}
    .tab.active.c{background:linear-gradient(135deg,#f5576c 0%,#f093fb 100%);
      border-bottom-color:#f5576c}
    .tab:focus{outline:3px solid rgba(74,144,226,0.12);outline-offset:2px}
    .tab[aria-pressed="true"]{font-weight:900}

    .chartBox{background:#fff;border:1px solid #ECECEC;border-radius:14px;padding:12px 12px 10px}
    .chartHead{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;flex-wrap:wrap;margin-bottom:6px}
    .chartHead .title{font-weight:900}
    .chartWrap{height:280px;position:relative}
    .chartFootnote{margin-top:12px;font-size:.85em;color:#5D6D7E;line-height:2.1}
    .notes{margin-top:16px;background:#fff;border:1px solid #ECECEC;border-radius:14px;padding:18px 20px}
    .notes .notesTitle{font-weight:900;margin-bottom:10px;font-size:1.05em}
    .notes .notesBody{font-size:.95em;color:#34495E;line-height:2.1}
    .notes ul{padding-left:22px}
    .notes li{margin:8px 0}

    .detailTable{margin-top:16px;background:#fff;border:1px solid #ECECEC;border-radius:14px;padding:16px 20px}
    .detailTable .tableTitle{font-weight:900;margin-bottom:12px;font-size:1.05em;color:#2C3E50}
    .detailTable table{width:100%;border-collapse:collapse;font-size:.88em}
    .detailTable th{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;
      font-weight:800;padding:10px 8px;text-align:center;border:1px solid #E2E8F0}
    .detailTable td{padding:9px 8px;text-align:center;border:1px solid #E2E8F0;color:#2C3E50}
    .detailTable tbody tr:hover{background:#F8FAFC}
    .detailTable .total-row{background:linear-gradient(135deg,#e0f2fe 0%,#dbeafe 100%);font-weight:900}
    .detailTable .total-row td{color:#1e40af;font-size:.95em}

    /* subtle pulse on tab change */
    .chartBox.pulse{animation:pulseGlow .55s ease-out}
    @keyframes pulseGlow{
      0%{transform:scale(.997);box-shadow:0 3px 14px rgba(0,0,0,.06)}
      45%{transform:scale(1.01);box-shadow:0 12px 28px rgba(74,144,226,.16)}
      100%{transform:scale(1);box-shadow:0 3px 14px rgba(0,0,0,.06)}
    }
  </style>
</head>
<body>
<div class="container">
  <header>
    <h1>ë¯¸ë˜ì„±ì¥í™œë™ ì°¸ì—¬ìœ¨ í˜„í™©</h1>
    <div class="meta-row">
      <div class="meta-item">
        <span class="meta-label">ğŸ¢ ëŒ€ìƒë²•ì¸</span>
        <span class="meta-value">DRBë™ì¼, ë™ì¼ê³ ë¬´ë²¨íŠ¸, DRBì˜¤í† ëª¨í‹°ë¸Œ</span>
      </div>
      <div class="meta-item period">
        <span class="meta-label">ğŸ“… ëŒ€ìƒê¸°ê°„</span>
        <span class="meta-value">2022ë…„ ~ 2025ë…„</span>
      </div>
    </div>
  </header>

  <!-- 2025ë…„ ê¸°ì¤€ ìš”ì•½: (1) ë¯¸ë˜ì„±ì¥(í• ë‹¹ì¸ì›) ì ìœ  (2) ë¯¸ë˜ì„±ì¥(ì°¸ì—¬ì¸ì›) ì ìœ  -->
  <div class="grid top-grid" id="summaryCards">
    <!-- JSë¡œ ì±„ì›€ -->
  </div>

  <div class="section">
    <div class="section-title"><span class="bar"></span><span>ğŸ“ˆ 2022ë…„ ~ 2025ë…„ ë¯¸ë˜ì„±ì¥ ì¸ì› ì¶”ì´</span></div>

    <div class="tabs">
      <button class="tab total active" onclick="showSeries('total')">ì „ì²´</button>
      <button class="tab b" onclick="showSeries('b')">DRBë™ì¼</button>
      <button class="tab a" onclick="showSeries('a')">ë™ì¼ê³ ë¬´ë²¨íŠ¸</button>
      <button class="tab c" onclick="showSeries('c')">DRBì˜¤í† ëª¨í‹°ë¸Œ</button>
    </div>

    <div class="chartBox" id="chartBox">
      <div class="chartHead">
        <div class="title" id="chartTitle">ì „ì²´ Â· ë¯¸ë˜ì„±ì¥ ì¸ì› ì¶”ì´</div>
      </div>
      <div class="chartWrap"><canvas id="trendChart"></canvas></div>

      <div class="chartFootnote">
        <div>â€» ë¯¸ë˜ì„±ì¥(í• ë‹¹ì¸ì›) : ë¯¸ë˜ì„±ì¥ ì°¸ì—¬ì¸ì›ì˜ ì—…ë¬´ì—ì„œ ì‹¤ì§ˆì ìœ¼ë¡œ ë¯¸ë˜ì„±ì¥í™œë™ ì—…ë¬´ì‹œê°„ì„ ì¸ì›ìœ¼ë¡œ í™˜ì‚°</div>
        <div>â€» ë¯¸ë˜ì„±ì¥(ì°¸ì—¬ì¸ì›) : ë¯¸ë˜ì„±ì¥í™œë™ì— ì°¸ì—¬í•œ ì¸ì›</div>
      </div>

      <div class="notes">
        <div class="notesTitle" id="notesTitle">ì „ì²´ Â· ë©”ëª¨</div>
        <div class="notesBody" id="notesBody">
          <ul>
            <li>ì—¬ê¸°ì— 'ì „ì²´' ë¶„ì„ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”.</li>
            <li>ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ë²•ì¸ë³„ë¡œ ë‹¤ë¥¸ ë‚´ìš©ì´ í‘œì‹œë©ë‹ˆë‹¤.</li>
          </ul>
        </div>
      </div>

      <div class="detailTable" id="detailTable">
        <div class="tableTitle" id="tableTitle">ì „ì²´ Â· ì„¸ë¶€ í˜„í™© (2025ë…„)</div>
        <div id="tableContent"></div>
      </div>
    </div>
  </div>
</div>

<script>
  // ---------- Data (from provided tables) ----------
  const YEARS = ["2022ë…„","2023ë…„","2024ë…„","2025ë…„","2026ë…„","2027ë…„"];

  // ì „ì²´ ì¸ì›(ì—°ë„ë³„) - ë²•ì¸ë³„
  const HEADCOUNT = {
    total: [351, 351, 351, 377],
    b: [97, 97, 97, 111],
    a: [185, 185, 185, 192],
    c: [69, 69, 69, 74]
  };

  // ì„ í˜• íšŒê·€ë¥¼ ì´ìš©í•œ ì˜ˆì¸¡ í•¨ìˆ˜
  function predictLinear(values) {
    const n = values.length;
    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
    for (let i = 0; i < n; i++) {
      sumX += i;
      sumY += values[i];
      sumXY += i * values[i];
      sumX2 += i * i;
    }
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    return { slope, intercept };
  }

  function forecast(values, periods) {
    const { slope, intercept } = predictLinear(values);
    const result = [...values];
    for (let i = 1; i <= periods; i++) {
      const predicted = slope * (values.length + i - 1) + intercept;
      result.push(Math.max(0, predicted));
    }
    return result;
  }

  // ë¯¸ë˜ì„±ì¥(í• ë‹¹ì¸ì›) - ì‹¤ì œê°’
  const ALLOC_ACTUAL = {
    b: [8.2, 10.3, 14.8, 20.4],
    a: [12.8, 15.6, 29.7, 35.8],
    c: [1.0, 1.0, 1.0, 2.2],
    total: [22.0, 26.8, 45.5, 58.4]
  };

  // ë¯¸ë˜ì„±ì¥(ì°¸ì—¬ì¸ì›) - ì‹¤ì œê°’
  const PART_ACTUAL = {
    b: [22.0, 24.0, 31.0, 48.0],
    a: [28.0, 31.0, 46.0, 69.0],
    c: [5.0, 5.0, 5.0, 11.0],
    total: [55.0, 60.0, 82.0, 128.0]
  };

  // ì˜ˆì¸¡ê°’ í¬í•¨ ë°ì´í„° ìƒì„± (2026ë…„, 2027ë…„ë§Œ ì˜ˆì¸¡)
  const ALLOC = {
    b: forecast(ALLOC_ACTUAL.b, 2),
    a: forecast(ALLOC_ACTUAL.a, 2),
    c: [],
    total: forecast(ALLOC_ACTUAL.total, 2)
  };

  const PART = {
    b: forecast(PART_ACTUAL.b, 2),
    a: forecast(PART_ACTUAL.a, 2),
    c: [],
    total: forecast(PART_ACTUAL.total, 2)
  };

  // Cë²•ì¸ ì˜ˆì¸¡: Bë²•ì¸ê³¼ Aë²•ì¸ì˜ í‰ê·  ì¦ê°€ìœ¨ ì‚¬ìš©
  function forecastWithAvgGrowth(actual, bForecast, aForecast) {
    const result = [...actual];

    // Bë²•ì¸ê³¼ Aë²•ì¸ì˜ 2025ë…„ ëŒ€ë¹„ 2026ë…„ ì¦ê°€ìœ¨
    const bGrowth2026 = (bForecast[4] - bForecast[3]) / bForecast[3];
    const aGrowth2026 = (aForecast[4] - aForecast[3]) / aForecast[3];
    const avgGrowth2026 = (bGrowth2026 + aGrowth2026) / 2;

    // Bë²•ì¸ê³¼ Aë²•ì¸ì˜ 2026ë…„ ëŒ€ë¹„ 2027ë…„ ì¦ê°€ìœ¨
    const bGrowth2027 = (bForecast[5] - bForecast[4]) / bForecast[4];
    const aGrowth2027 = (aForecast[5] - aForecast[4]) / aForecast[4];
    const avgGrowth2027 = (bGrowth2027 + aGrowth2027) / 2;

    // Cë²•ì¸ 2026ë…„ = 2025ë…„ * (1 + í‰ê· ì¦ê°€ìœ¨)
    const c2026 = actual[3] * (1 + avgGrowth2026);
    result.push(Math.max(0, c2026));

    // Cë²•ì¸ 2027ë…„ = 2026ë…„ * (1 + í‰ê· ì¦ê°€ìœ¨)
    const c2027 = c2026 * (1 + avgGrowth2027);
    result.push(Math.max(0, c2027));

    return result;
  }

  // Cë²•ì¸ í• ë‹¹ì¸ì› ì˜ˆì¸¡
  ALLOC.c = forecastWithAvgGrowth(ALLOC_ACTUAL.c, ALLOC.b, ALLOC.a);

  // Cë²•ì¸ ì°¸ì—¬ì¸ì› ì˜ˆì¸¡
  PART.c = forecastWithAvgGrowth(PART_ACTUAL.c, PART.b, PART.a);

  const META = {
    total: { label: "ì „ì²´", allocColor:"#4A5FD9", partColor:"#E67E22" },
    b:     { label: "DRBë™ì¼", allocColor:"#4A5FD9", partColor:"#E67E22" },
    a:     { label: "ë™ì¼ê³ ë¬´ë²¨íŠ¸", allocColor:"#11998e", partColor:"#E67E22" },
    c:     { label: "DRBì˜¤í† ëª¨í‹°ë¸Œ", allocColor:"#f5576c", partColor:"#E67E22" }
  };

  const NOTES = {
    total: { title:"ì „ì²´ Â· ë©”ëª¨", body:`<ul><li>ì—¬ê¸°ì— 'ì „ì²´' ë¶„ì„ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”.</li><li>ì˜ˆ: 2024â†’2025 ì¦ê°€ ìš”ì¸ ë° ìš´ì˜ ì‹œì‚¬ì </li></ul>` },
    b:     { title:"DRBë™ì¼ Â· ë©”ëª¨", body:`<ul><li>ì—¬ê¸°ì— 'DRBë™ì¼' ë¶„ì„ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”.</li></ul>` },
    a:     { title:"ë™ì¼ê³ ë¬´ë²¨íŠ¸ Â· ë©”ëª¨", body:`<ul><li>ì—¬ê¸°ì— 'ë™ì¼ê³ ë¬´ë²¨íŠ¸' ë¶„ì„ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”.</li></ul>` },
    c:     { title:"DRBì˜¤í† ëª¨í‹°ë¸Œ Â· ë©”ëª¨", body:`<ul><li>ì—¬ê¸°ì— 'DRBì˜¤í† ëª¨í‹°ë¸Œ' ë¶„ì„ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”.</li></ul>` }
  };

  // ì„¸ë¶€ í˜„í™© ë°ì´í„° (2025ë…„ ê¸°ì¤€)
  const DETAIL_DATA = {
    a: [
      {dept:'ëŒ€í‘œì´ì‚¬', alloc:0.5, part:1.0, total:1.0, ratio:50},
      {dept:'ê¸°ìˆ ê³ ë¬¸', alloc:1.0, part:1.0, total:1.0, ratio:100},
      {dept:'ì¬ë¬´íŒ€', alloc:0.1, part:2.0, total:5.0, ratio:2},
      {dept:'ì—°êµ¬ì†Œ', alloc:13.5, part:16.0, total:25.0, ratio:54},
      {dept:'ìœµí•©ìë™í™”ì„¼í„°', alloc:14.4, part:15.0, total:16.0, ratio:90},
      {dept:'ë²¨íŠ¸ì‚¬ì—…ë¶€ë¬¸', alloc:2.4, part:19.0, total:66.0, ratio:4},
      {dept:'íŠ¸ë™ì‚¬ì—…ë¶€ë¬¸', alloc:1.0, part:4.0, total:24.0, ratio:4},
      {dept:'ì—”ì§€ë‹ˆì–´ë§ì‚¬ì—…', alloc:0.4, part:4.0, total:15.0, ratio:3},
      {dept:'ë¯¸ë˜ì„±ì¥íŒ€', alloc:1.5, part:4.0, total:4.0, ratio:38},
      {dept:'ê²½ì˜ê´€ë¦¬ë¶€ë¬¸', alloc:0.6, part:2.0, total:9.0, ratio:7},
      {dept:'í’ˆì§ˆë³´ì¦íŒ€', alloc:0.3, part:1.0, total:6.0, ratio:5},
      {dept:'ë¯¸ì°¸ì—¬', alloc:0.0, part:0.0, total:20.0, ratio:0}
    ],
    b: [
      {dept:'ëŒ€í‘œì´ì‚¬', alloc:0.3, part:1, total:1, ratio:30},
      {dept:'ìš´ì˜ì´ì‚¬', alloc:1.0, part:1, total:1, ratio:100},
      {dept:'ê°ì‚¬íŒ€', alloc:1.6, part:1, total:3, ratio:53},
      {dept:'ë¸Œëœë“œë””ìì¸ë‹´ë‹¹', alloc:1.0, part:1, total:2, ratio:50},
      {dept:'ë””ì§€í„¸ì „ëµì„¼í„°', alloc:3.8, part:10, total:29, ratio:13},
      {dept:'ë¯¸ë˜ì„±ì¥ë¶€ë¬¸', alloc:9.0, part:11, total:11, ratio:82},
      {dept:'ì§€ì†ì„±ì¥ë¶€ë¬¸', alloc:2.2, part:17, total:32, ratio:7},
      {dept:'Finance&Complianceë¶€ë¬¸', alloc:0.6, part:3, total:22, ratio:3},
      {dept:'ìš´ì˜ì´ì‚¬', alloc:0.9, part:3, total:8, ratio:11},
      {dept:'ë¯¸ì°¸ì—¬', alloc:0.0, part:0, total:2, ratio:0}
    ],
    c: [
      {dept:'ì˜ì—…ê¸°íšì´ì‚¬', alloc:0.4, part:4.0, total:13.0, ratio:3},
      {dept:'ìƒì‚°íŒ€', alloc:0.3, part:2.0, total:13.0, ratio:2},
      {dept:'ìƒì‚°ê¸°ìˆ íŒ€', alloc:0.3, part:1.0, total:9.0, ratio:4},
      {dept:'ëª¨ë¹Œë¦¬í‹°R&Dì„¼í„°', alloc:0.9, part:3.0, total:19.0, ratio:5},
      {dept:'í’ˆì§ˆë³´ì¦íŒ€', alloc:0.3, part:1.0, total:12.0, ratio:3},
      {dept:'ë¯¸ì°¸ì—¬', alloc:0.0, part:0.0, total:8.0, ratio:0}
    ]
  };

  // ì „ì²´ ë°ì´í„°ëŠ” DRBë™ì¼, ë™ì¼ê³ ë¬´ë²¨íŠ¸, DRBì˜¤í† ëª¨í‹°ë¸Œ ìˆœì„œë¡œ í•©ì‚°
  DETAIL_DATA.total = [
    ...DETAIL_DATA.b.map(d => ({...d, corp:'DRBë™ì¼'})),
    ...DETAIL_DATA.a.map(d => ({...d, corp:'ë™ì¼ê³ ë¬´ë²¨íŠ¸'})),
    ...DETAIL_DATA.c.map(d => ({...d, corp:'DRBì˜¤í† ëª¨í‹°ë¸Œ'}))
  ];

  // ---------- Summary (2025 share donuts) ----------
  function pct(part, total){
    if (!total) return 0;
    return Math.max(0, Math.min(100, (part/total)*100));
  }

  function donut(canvas, percent, color, empty){
    return new Chart(canvas.getContext('2d'), {
      type: 'doughnut',
      data: { datasets:[{ data:[percent, 100-percent], backgroundColor:[color, empty], borderWidth:0 }] },
      options: {
        responsive:true, maintainAspectRatio:false,
        cutout:'74%',
        plugins:{ legend:{display:false}, tooltip:{enabled:false} }
      }
    });
  }

  function buildSummary(){
    const cards = document.getElementById('summaryCards');
    cards.innerHTML = '';

    // ìˆœì„œ: ì „ì²´, Bë²•ì¸, Aë²•ì¸, Cë²•ì¸
    const order = ["total","b","a","c"];
    order.forEach(key=>{
      const label = META[key].label;
      const alloc2025 = ALLOC[key][3];
      const part2025  = PART[key][3];
      const head2025 = HEADCOUNT[key][3]; // ë²•ì¸ë³„ ì „ì²´ ì¸ì›

      const isTotal = key === 'total';
      const card = document.createElement('div');
      card.className = 'card' + (isTotal ? ' total' : '');

      const title = document.createElement('div');
      title.className = 'card-title';
      title.textContent = (isTotal ? "ì „ì²´" : label);

      const row = document.createElement('div');
      row.className = 'mini-row';

      const wrap = document.createElement('div');
      wrap.className = 'donutWrap' + (isTotal ? ' big' : '');

      const cv = document.createElement('canvas');
      wrap.appendChild(cv);

      const center = document.createElement('div');
      center.className = 'centerTxt';
      const p = document.createElement('div');
      p.className = 'pct';
      // ì°¸ì—¬ì¸ì› / ì „ì²´ì¸ì›
      const share = pct(part2025, head2025);
      p.textContent = share.toFixed(0) + '%';
      const sub = document.createElement('div');
      sub.className = 'sub';
      sub.textContent = '';
      sub.style.display = 'none';
      center.appendChild(p); center.appendChild(sub);
      wrap.appendChild(center);

      const metric = document.createElement('div');
      metric.className = 'metric';
      const main = document.createElement('div');
      main.className = 'main';
      main.textContent = `ì°¸ì—¬ ${part2025.toFixed(1)}ëª… / í• ë‹¹ ${alloc2025.toFixed(1)}ëª…`;
      const hint = document.createElement('div');
      hint.className = 'hint';
      hint.textContent = `ì „ì²´ ${head2025}ëª…`;
      metric.appendChild(main); metric.appendChild(hint);

      row.appendChild(wrap); row.appendChild(metric);
      card.appendChild(title); card.appendChild(row);
      cards.appendChild(card);

      // create donut chart (ì°¸ì—¬ì¸ì› ë¹„ìœ¨)
      const fill = isTotal ? 'rgba(255,255,255,0.95)' : META[key].allocColor;
      const empty = isTotal ? 'rgba(255,255,255,0.22)' : 'rgba(0,0,0,0.08)';
      donut(cv, share, fill, empty);
    });
  }

  buildSummary();

  // ---------- Line chart with two datasets + datalabels (custom plugin) ----------
  const pointValueLabelsPlugin = {
    id: 'pointValueLabels',
    afterDatasetsDraw(chart, args, pluginOptions){
      if (!pluginOptions || pluginOptions.enabled === false) return;
      if (chart.config.type !== 'line') return;

      const { ctx } = chart;
      ctx.save();
      ctx.font = '700 12px Segoe UI, Malgun Gothic, sans-serif';
      ctx.fillStyle = '#2C3E50';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';

      chart.data.datasets.forEach((ds, di)=>{
        const meta = chart.getDatasetMeta(di);
        if (meta.hidden) return;

        meta.data.forEach((pt, i)=>{
          const num = Number(ds.data[i]);
          if (!isFinite(num) || num === null) return;

          // 2026ë…„, 2027ë…„(ì¸ë±ìŠ¤ 4, 5)ì€ ì˜ˆìƒê°’ë§Œ í‘œì‹œ
          if (i >= 4) {
            // ì˜ˆìƒ ë°ì´í„°ì…‹(ì¸ë±ìŠ¤ 1, 3)ë§Œ í‘œì‹œ
            if (di !== 1 && di !== 3) return;
          } else {
            // 2022~2025ë…„ì€ ì‹¤ì œê°’(ì¸ë±ìŠ¤ 0, 2)ë§Œ í‘œì‹œ
            if (di === 1 || di === 3) return;
          }

          // ì†Œìˆ˜ì  í•œ ìë¦¬ í˜•ì‹
          const txt = num.toFixed(1) + 'ëª…';
          const x = pt.x;
          let y = Math.max(pt.y - 14, chart.chartArea.top + 12);

          // 2025ë…„(ì¸ë±ìŠ¤ 3)ì€ ì§„í•œ íŒŒë€ìƒ‰, ë‚˜ë¨¸ì§€ëŠ” ê²€ì •ìƒ‰
          if (i === 3) {
            ctx.fillStyle = '#1e40af';
            ctx.font = '900 13px Segoe UI, Malgun Gothic, sans-serif';
          } else {
            ctx.fillStyle = '#2C3E50';
            ctx.font = '700 12px Segoe UI, Malgun Gothic, sans-serif';
          }

          // Adjust label position to avoid overlap
          if (i === 3 || i >= 4) {
            y = Math.max(pt.y - 18, chart.chartArea.top + 12);
          }
          ctx.fillText(txt, x, y);
        });
      });

      ctx.restore();
    }
  };
  Chart.register(pointValueLabelsPlugin);

  let trendChart;

  function niceMax(values, seriesKey){
    const maxVal = Math.max.apply(null, values);
    // ì „ì²´ì˜ ê²½ìš° 250ìœ¼ë¡œ ê³ ì •
    if (seriesKey === 'total') {
      return 250;
    }
    const head = maxVal * 1.35;
    // round up to nearest 10
    return Math.ceil(head / 10) * 10;
  }

  function makeTrendChart(seriesKey){
    const meta = META[seriesKey];
    const alloc = ALLOC[seriesKey];
    const part  = PART[seriesKey];
    const allocActual = ALLOC_ACTUAL[seriesKey];
    const partActual = PART_ACTUAL[seriesKey];
    const suggestedMax = niceMax(alloc.concat(part), seriesKey);

    const ctx = document.getElementById('trendChart').getContext('2d');

    // ì‹¤ì œê°’ê³¼ ì˜ˆì¸¡ê°’ì„ ë¶„ë¦¬í•˜ì—¬ ë°ì´í„°ì…‹ ìƒì„±
    const allocActualData = [...allocActual, ...Array(2).fill(null)];
    const allocForecastData = [...Array(3).fill(null), allocActual[3], ...alloc.slice(4)];

    const partActualData = [...partActual, ...Array(2).fill(null)];
    const partForecastData = [...Array(3).fill(null), partActual[3], ...part.slice(4)];

    const data = {
      labels: YEARS,
      datasets: [
        {
          label: "ë¯¸ë˜ì„±ì¥(í• ë‹¹ì¸ì›)",
          data: allocActualData,
          borderColor: meta.allocColor,
          backgroundColor: meta.allocColor,
          borderWidth: 4,
          tension: 0.25,
          pointRadius: 6,
          pointHoverRadius: 7,
          pointBorderWidth: 2,
          pointBackgroundColor: "#ffffff",
          fill: false,
          spanGaps: false
        },
        {
          label: "ë¯¸ë˜ì„±ì¥(í• ë‹¹ì¸ì›) ì˜ˆìƒ",
          data: allocForecastData,
          borderColor: meta.allocColor,
          backgroundColor: meta.allocColor,
          borderWidth: 3,
          borderDash: [8, 4],
          tension: 0.25,
          pointRadius: 5,
          pointHoverRadius: 6,
          pointBorderWidth: 2,
          pointBackgroundColor: "#ffffff",
          pointStyle: 'circle',
          fill: false,
          spanGaps: false,
          datalabels: { display: false }
        },
        {
          label: "ë¯¸ë˜ì„±ì¥(ì°¸ì—¬ì¸ì›)",
          data: partActualData,
          borderColor: meta.partColor,
          backgroundColor: meta.partColor,
          borderWidth: 4,
          tension: 0.25,
          pointRadius: 6,
          pointHoverRadius: 7,
          pointBorderWidth: 2,
          pointBackgroundColor: "#ffffff",
          fill: false,
          spanGaps: false
        },
        {
          label: "ë¯¸ë˜ì„±ì¥(ì°¸ì—¬ì¸ì›) ì˜ˆìƒ",
          data: partForecastData,
          borderColor: meta.partColor,
          backgroundColor: meta.partColor,
          borderWidth: 3,
          borderDash: [8, 4],
          tension: 0.25,
          pointRadius: 5,
          pointHoverRadius: 6,
          pointBorderWidth: 2,
          pointBackgroundColor: "#ffffff",
          pointStyle: 'circle',
          fill: false,
          spanGaps: false,
          datalabels: { display: false }
        }
      ]
    };

    const options = {
      responsive:true,
      maintainAspectRatio:false,
      animation:{ duration: 850, easing:'easeOutQuart' },
      plugins:{
        legend:{
          display:true,
          position:'top',
          align:'end',
          labels:{
            usePointStyle:true,
            boxWidth:8,
            padding:10,
            font:{ weight:'700', size:11 },
            filter: function(item, chart) {
              return !item.text.includes('ì˜ˆìƒ');
            }
          }
        },
        tooltip:{
          callbacks:{
            label:(ctx)=>` ${Math.round(ctx.parsed.y)}ëª…`
          }
        },
        pointValueLabels:{ enabled:true }
      },
      layout:{ padding:{ left:12, right:16, top:8, bottom:0 } },
      scales:{
        x:{
          offset:true,
          grid:{ display:false },
          ticks:{
            color:'#2C3E50',
            font:{ weight:'700', size:13 }
          }
        },
        y:{
          beginAtZero:true,
          suggestedMax: suggestedMax,
          grid:{ display:false },
          title:{ display:true, text:"ì¸ì›", align:'end', color:'#2C3E50', font:{ weight:'800' } },
          ticks:{
            color:'#2C3E50',
            font:{ weight:'700' },
            stepSize: seriesKey === 'total' ? 50 : 20,
            callback:(v)=>Math.round(v)+'ëª…'
          }
        }
      }
    };

    if (trendChart) trendChart.destroy();
    trendChart = new Chart(ctx, { type:'line', data, options });
    trendChart.$seriesKey = seriesKey;

    document.getElementById('chartTitle').textContent = `${meta.label} Â· ë¯¸ë˜ì„±ì¥ ì¸ì› ì¶”ì´`;
  }

  function setActiveTab(key){
    document.querySelectorAll('.tab').forEach(b=>{
      b.classList.remove('active');
      b.setAttribute('aria-pressed','false');
    });
    const btnMap = { total:'.tab.total', b:'.tab.b', a:'.tab.a', c:'.tab.c' };
    const btn = document.querySelector(btnMap[key]);
    if (btn){
      btn.classList.add('active');
      btn.setAttribute('aria-pressed','true');
      try{ btn.focus({preventScroll:true}); }catch(e){ btn.focus(); }
    }
  }

  function buildDetailTable(key) {
    const rawData = DETAIL_DATA[key] || [];
    const label = META[key].label;

    document.getElementById('tableTitle').textContent = `${label} Â· ì„¸ë¶€ í˜„í™© (2025ë…„)`;

    // ë°ì´í„° ì •ë ¬: ë¯¸ì°¸ì—¬ë¥¼ ì œì™¸í•˜ê³  ì°¸ì—¬ìœ¨ ë‚´ë¦¼ì°¨ìˆœ, ë¯¸ì°¸ì—¬ëŠ” ë§¨ ì•„ë˜
    let sortedData = [];
    if (key === 'total') {
      // ì „ì²´ì˜ ê²½ìš° ë²•ì¸ë³„ë¡œ ê·¸ë£¹í™”í•˜ì—¬ ì •ë ¬ (DRBë™ì¼, ë™ì¼ê³ ë¬´ë²¨íŠ¸, DRBì˜¤í† ëª¨í‹°ë¸Œ ìˆœì„œ)
      const corps = ['DRBë™ì¼', 'ë™ì¼ê³ ë¬´ë²¨íŠ¸', 'DRBì˜¤í† ëª¨í‹°ë¸Œ'];
      corps.forEach(corp => {
        const corpData = rawData.filter(d => d.corp === corp);
        const nonMiparticipant = corpData.filter(d => d.dept !== 'ë¯¸ì°¸ì—¬').sort((a, b) => b.ratio - a.ratio);
        const miparticipant = corpData.filter(d => d.dept === 'ë¯¸ì°¸ì—¬');
        sortedData = sortedData.concat(nonMiparticipant, miparticipant);
      });
    } else {
      // ê°œë³„ ë²•ì¸ì˜ ê²½ìš°
      const nonMiparticipant = rawData.filter(d => d.dept !== 'ë¯¸ì°¸ì—¬').sort((a, b) => b.ratio - a.ratio);
      const miparticipant = rawData.filter(d => d.dept === 'ë¯¸ì°¸ì—¬');
      sortedData = nonMiparticipant.concat(miparticipant);
    }

    let html = '<table><thead><tr>';

    if (key === 'total') {
      html += '<th>ë²•ì¸</th>';
    }
    html += '<th>íŒ€ëª…</th><th>í• ë‹¹ ì¸ì›(ëª…)</th><th>ì°¸ì—¬ ì¸ì›(ëª…)</th><th>ì „ì²´ ì¸ì›(ëª…)</th><th>ì°¸ì—¬ìœ¨(%)</th>';
    html += '</tr></thead><tbody>';

    let totalAlloc = 0, totalPart = 0, totalHead = 0;
    let currentCorp = '';
    let corpRowCount = 0;
    let corpStartIndex = 0;
    let corpAlloc = 0, corpPart = 0, corpHead = 0;

    sortedData.forEach((row, idx) => {
      if (key === 'total') {
        if (currentCorp !== row.corp) {
          // ì´ì „ ë²•ì¸ì˜ ì†Œê³„ ì¶œë ¥ (ì²« ë²ˆì§¸ ë²•ì¸ì´ ì•„ë‹Œ ê²½ìš°)
          if (currentCorp !== '') {
            const corpRatio = corpHead > 0 ? Math.round((corpPart / corpHead) * 100) : 0;
            html += '<tr style="background:#f0f4f8;font-weight:700;border-top:2px solid #cbd5e0">';
            html += `<td colspan="2" style="text-align:center">${currentCorp} ì†Œê³„</td>`;
            html += `<td>${corpAlloc.toFixed(1)}</td>`;
            html += `<td>${corpPart.toFixed(1)}</td>`;
            html += `<td>${corpHead.toFixed(1)}</td>`;
            html += `<td>${corpRatio}%</td>`;
            html += '</tr>';
          }

          currentCorp = row.corp;
          corpStartIndex = idx;
          corpRowCount = sortedData.filter(d => d.corp === row.corp).length;
          corpAlloc = 0;
          corpPart = 0;
          corpHead = 0;
        }
      }

      html += '<tr>';

      if (key === 'total') {
        if (idx === corpStartIndex) {
          html += `<td rowspan="${corpRowCount}">${row.corp}</td>`;
        }
      }

      html += `<td>${row.dept}</td>`;
      html += `<td>${row.alloc.toFixed(1)}</td>`;
      html += `<td>${row.part.toFixed(1)}</td>`;
      html += `<td>${row.total.toFixed(1)}</td>`;
      html += `<td>${row.ratio}%</td>`;
      html += '</tr>';

      totalAlloc += row.alloc;
      totalPart += row.part;
      totalHead += row.total;

      if (key === 'total') {
        corpAlloc += row.alloc;
        corpPart += row.part;
        corpHead += row.total;
      }
    });

    // ë§ˆì§€ë§‰ ë²•ì¸ì˜ ì†Œê³„ ì¶œë ¥
    if (key === 'total' && currentCorp !== '') {
      const corpRatio = corpHead > 0 ? Math.round((corpPart / corpHead) * 100) : 0;
      html += '<tr style="background:#f0f4f8;font-weight:700;border-top:2px solid #cbd5e0">';
      html += `<td colspan="2" style="text-align:center">${currentCorp} ì†Œê³„</td>`;
      html += `<td>${corpAlloc.toFixed(1)}</td>`;
      html += `<td>${corpPart.toFixed(1)}</td>`;
      html += `<td>${corpHead.toFixed(1)}</td>`;
      html += `<td>${corpRatio}%</td>`;
      html += '</tr>';
    }

    const totalRatio = totalHead > 0 ? Math.round((totalPart / totalHead) * 100) : 0;

    html += '<tr class="total-row">';
    if (key === 'total') {
      html += '<td colspan="2" style="text-align:center">í•©ê³„</td>';
    } else {
      html += '<td>í•©ê³„</td>';
    }
    html += `<td>${totalAlloc.toFixed(1)}</td>`;
    html += `<td>${totalPart.toFixed(1)}</td>`;
    html += `<td>${totalHead.toFixed(1)}</td>`;
    html += `<td>${totalRatio}%</td>`;
    html += '</tr>';

    html += '</tbody></table>';

    document.getElementById('tableContent').innerHTML = html;
  }

  function showSeries(key){
    setActiveTab(key);
    makeTrendChart(key);

    const n = NOTES[key] || NOTES.total;
    document.getElementById('notesTitle').textContent = n.title;
    document.getElementById('notesBody').innerHTML = n.body;

    buildDetailTable(key);

    const box = document.getElementById('chartBox');
    box.classList.remove('pulse'); void box.offsetWidth;
    box.classList.add('pulse');
    setTimeout(()=>box.classList.remove('pulse'), 650);
  }

  // init
  showSeries('total');
</script>
</body>
</html>
